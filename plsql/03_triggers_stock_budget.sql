-- Stock management trigger
-- - Error if insufficient stock
-- - Increment/decrement stock
-- - Internal alert if stock <= threshold

CREATE OR REPLACE TRIGGER trg_gestion_stock
FOR INSERT OR UPDATE OR DELETE ON COLIS_PRODUIT
COMPOUND TRIGGER

    TYPE t_produits IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;
    g_produits_modifies t_produits;

    PROCEDURE marquer_produit(pid NUMBER) IS
    BEGIN
        IF pid IS NOT NULL THEN
            g_produits_modifies(TRUNC(pid)) := TRUE;
        END IF;
    END;

    BEFORE EACH ROW IS
        v_stock_actuel  NUMBER;
        v_nouvelle_qte  NUMBER;
    BEGIN
        IF INSERTING OR UPDATING THEN
            SELECT quantite_stock INTO v_stock_actuel
            FROM PRODUITS
            WHERE id_produit = :NEW.id_produit;

            v_nouvelle_qte := NVL(:NEW.quantite_utilisee, 0);

            IF UPDATING THEN
                v_nouvelle_qte := v_nouvelle_qte - NVL(:OLD.quantite_utilisee, 0);
            END IF;

            -- Check sufficient stock
            IF v_stock_actuel < v_nouvelle_qte THEN
                RAISE_APPLICATION_ERROR(-60010,
                    'Insufficient stock for product ' || :NEW.id_produit
                );
            END IF;

            -- Decrement stock
            UPDATE PRODUITS
            SET quantite_stock = quantite_stock - v_nouvelle_qte
            WHERE id_produit = :NEW.id_produit;

            marquer_produit(:NEW.id_produit);
        END IF;

        IF DELETING THEN
            -- Increment stock
            UPDATE PRODUITS
            SET quantite_stock = quantite_stock + :OLD.quantite_utilisee
            WHERE id_produit = :OLD.id_produit;

            marquer_produit(:OLD.id_produit);
        END IF;

        IF UPDATING THEN
            marquer_produit(:OLD.id_produit);
        END IF;
    END BEFORE EACH ROW;

    -- After statement: check thresholds
    AFTER STATEMENT IS
        v_stock NUMBER;
        v_seuil NUMBER;
        k       PLS_INTEGER;
    BEGIN
        k := g_produits_modifies.FIRST;
        WHILE k IS NOT NULL LOOP
            SELECT quantite_stock, seuil_alerte
            INTO v_stock, v_seuil
            FROM PRODUITS
            WHERE id_produit = k;

            -- Alert if stock <= threshold
            IF v_stock <= v_seuil THEN
                DBMS_OUTPUT.PUT_LINE(
                    'ALERT: Low stock for product ' || k ||
                    ' (stock=' || v_stock || ', threshold=' || v_seuil || ')'
                );
            END IF;

            k := g_produits_modifies.NEXT(k);
        END LOOP;
    END AFTER STATEMENT;

END trg_gestion_stock;
/


-- Donation amount must be > 0
  
ALTER TABLE DONS ADD CONSTRAINT chk_montant_positif CHECK (montant > 0);

-- Create BUDGET table (id=1 for global budget)
CREATE TABLE BUDGET (
    id_budget NUMBER PRIMARY KEY,
    solde     NUMBER NOT NULL CHECK (solde >= 0)
);

-- Create initial budget row
INSERT INTO BUDGET (id_budget, solde) VALUES (1, 0);


-- Check donation type validity

CREATE OR REPLACE TRIGGER trg_dons
BEFORE INSERT OR UPDATE ON DONS
FOR EACH ROW
BEGIN
    IF :NEW.type_don NOT IN ('Alimentaire','Argent','Hygiène') THEN
        RAISE_APPLICATION_ERROR(
            -60020,
            'Invalid type_don (Alimentaire, Argent, Hygiène).'
        );
    END IF;
END;
/

-- Add to budget if donation type is money
  
CREATE OR REPLACE TRIGGER trg_dons_budget
AFTER INSERT ON DONS
FOR EACH ROW
BEGIN
    IF :NEW.type_don = 'Argent' THEN
        UPDATE BUDGET
        SET solde = solde + NVL(:NEW.montant, 0)
        WHERE id_budget = 1;
    END IF;
END;
/

-- Add to stock if the donation is a product donation
  
CREATE OR REPLACE TRIGGER trg_don_produit
AFTER INSERT ON DON_PRODUIT
FOR EACH ROW
BEGIN
    UPDATE PRODUITS
    SET quantite_stock = quantite_stock + :NEW.montant
    WHERE id_produit = :NEW.id_produit;
END;
/

-- Create ACHATS table
-- Product purchase decreases the budget and increases the stock
  
CREATE TABLE ACHATS (
    id_achat      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_produit    NUMBER NOT NULL REFERENCES PRODUITS(id_produit),
    quantite      NUMBER NOT NULL CHECK (quantite > 0),
    montant_total NUMBER NOT NULL CHECK (montant_total > 0)
);

-- Check sufficient budget before purchase
-- Decrement budget and increment stock after purchase
CREATE OR REPLACE TRIGGER trg_achats
BEFORE INSERT ON ACHATS
FOR EACH ROW
DECLARE
    v_solde NUMBER;
BEGIN
    SELECT solde INTO v_solde
    FROM BUDGET
    WHERE id_budget = 1;

    IF v_solde < :NEW.montant_total THEN
        RAISE_APPLICATION_ERROR(-60030, 'Insufficient budget for this purchase.');
    END IF;

    -- Debit budget
    UPDATE BUDGET
    SET solde = solde - :NEW.montant_total
    WHERE id_budget = 1;

    -- Add stock
    UPDATE PRODUITS
    SET quantite_stock = quantite_stock + :NEW.quantite
    WHERE id_produit = :NEW.id_produit;
END;
/


-- Prevent budget from becoming negative
  
CREATE OR REPLACE TRIGGER trg_budget_non_neg
BEFORE UPDATE OF solde ON BUDGET
FOR EACH ROW
BEGIN
    IF :NEW.solde < 0 THEN
        RAISE_APPLICATION_ERROR(-60040, 'Negative budget is forbidden.');
    END IF;
END;
/


-- Check: package size
  
ALTER TABLE COLIS
ADD CONSTRAINT chk_colis_taille
CHECK (taille_colis IN ('S','M','L','XL','XXL','XXXL'));

-- Check: package status
ALTER TABLE COLIS
ADD CONSTRAINT chk_colis_statut
CHECK (statut IN ('PREPARE','VALIDE'));

-- Check: distribution (recovered or not)
ALTER TABLE DISTRIBUTIONS
ADD CONSTRAINT chk_distribution_recupere
CHECK (recupere IN ('O','N'));


-- Trigger: general package checks
-- Covers: mandatory preparation date, beneficiary existence,
-- and forbid modifying a validated package

CREATE OR REPLACE TRIGGER trg_colis_controles
BEFORE INSERT OR UPDATE ON colis
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    -- Preparation date is mandatory
    IF :NEW.date_preparation IS NULL THEN
        RAISE_APPLICATION_ERROR(-20010, 'The package preparation date is mandatory.');
    END IF;

    -- Check that the beneficiary exists
    SELECT COUNT(*)
    INTO v_count
    FROM beneficiaires
    WHERE id_beneficiaire = :NEW.id_beneficiaire;

    IF v_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20011, 'Non-existing beneficiary.');
    END IF;

    -- Forbid modifying an already validated package
    IF UPDATING AND :OLD.statut = 'VALIDE' THEN
        RAISE_APPLICATION_ERROR(-20012, 'A validated package can no longer be modified.');
    END IF;
END;
/


-- Trigger: reintegrate stock when a distribution is canceled or reverted
CREATE OR REPLACE TRIGGER trg_distribution_reintegration_stock
AFTER INSERT OR UPDATE OF recupere ON distributions
FOR EACH ROW
DECLARE
    v_old_rec CHAR(1);
    v_new_rec CHAR(1);
    v_stock   NUMBER;
BEGIN
    v_old_rec := NVL(:OLD.recupere, 'O');
    v_new_rec := :NEW.recupere;

    -- Case O → N : reintegrate stock into products
    IF v_old_rec = 'O' AND v_new_rec = 'N' THEN
        FOR r IN (
            SELECT id_produit, quantite_utilisee
            FROM colis_produit
            WHERE id_colis = :NEW.id_colis
        ) LOOP
            UPDATE produits
            SET quantite_stock = quantite_stock + r.quantite_utilisee
            WHERE id_produit = r.id_produit;
        END LOOP;
    END IF;

    -- Case N → O : cancel reintegration (consume stock again)
    IF v_old_rec = 'N' AND v_new_rec = 'O' THEN
        FOR r IN (
            SELECT id_produit, quantite_utilisee
            FROM colis_produit
            WHERE id_colis = :NEW.id_colis
        ) LOOP
            -- Lock product to avoid inconsistencies
            SELECT quantite_stock
            INTO v_stock
            FROM produits
            WHERE id_produit = r.id_produit
            FOR UPDATE;

            IF v_stock < r.quantite_utilisee THEN
                RAISE_APPLICATION_ERROR(
                    -20005,
                    'Cannot switch to recovered: insufficient stock (reintegration already consumed).'
                );
            END IF;

            UPDATE produits
            SET quantite_stock = quantite_stock - r.quantite_utilisee
            WHERE id_produit = r.id_produit;
        END LOOP;
    END IF;
END;
/


-- Trigger: manage beneficiary absences and automatic deactivation
-- Rules:
--   - O → N : increment absences
--   - If absences > 5 → deactivate beneficiary
--   - O → O : reset absence counter
  
CREATE OR REPLACE TRIGGER trg_distribution_gestion_absences
AFTER INSERT OR UPDATE OF recupere ON distributions
FOR EACH ROW
DECLARE
    v_old_rec   CHAR(1);
    v_new_rec   CHAR(1);
    v_absences  NUMBER;
BEGIN
    v_old_rec := NVL(:OLD.recupere, 'O');
    v_new_rec := :NEW.recupere;

    -- Case O → N : absence detected
    IF v_old_rec = 'O' AND v_new_rec = 'N' THEN
        UPDATE beneficiaires
        SET nb_absences = NVL(nb_absences, 0) + 1
        WHERE id_beneficiaire = :NEW.id_beneficiaire;

        SELECT NVL(nb_absences, 0)
        INTO v_absences
        FROM beneficiaires
        WHERE id_beneficiaire = :NEW.id_beneficiaire;

        -- Deactivate beneficiary after 5 absences
        IF v_absences > 5 THEN
            UPDATE beneficiaires
            SET actif = 'N'
            WHERE id_beneficiaire = :NEW.id_beneficiaire;
        END IF;
    END IF;

    -- Case recovered again → reset absence counter
    IF v_new_rec = 'O' THEN
        UPDATE beneficiaires
        SET nb_absences = 0
        WHERE id_beneficiaire = :NEW.id_beneficiaire;
    END IF;
END;
/
